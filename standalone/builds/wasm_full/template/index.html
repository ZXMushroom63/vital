<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VialTemplate</title>
</head>

<body>
    <canvas width="400" height="300" id="canvas"
        style="position: fixed; left: 0px; top: 0px; width: 100vw; height: 100vh; z-index: -1; border: 1px solid black; image-rendering: pixelated; background: linear-gradient(132deg,rgba(65, 63, 110, 1) 0%, rgba(141, 138, 166, 1) 35%, rgba(128, 182, 194, 1) 100%);"></canvas>
    <br>
    <span>Checking WebGL Availability...</span>
    <button id="init">init</button>
    <button id="draw">draw</button>
    <script src="vial.js"></script>
    <script>
        function detectWebGLContext() {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl");
            return (gl instanceof WebGLRenderingContext)
                ? "Congratulations! Your browser supports WebGL."
                : "Failed. Your browser or device may not support WebGL.";
        }
        createModule({
            canvas: document.querySelector("#canvas")
        }).then(Vial => {
            globalThis.Vial = Vial;
        });

        addEventListener("contextmenu", (e) => { e.preventDefault(); });
        function debounce(func, delay) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }
        
        addEventListener("load", () => {
            let inited = false;
            document.querySelector("span").innerText = detectWebGLContext();
            document.querySelector("#init").addEventListener("click", () => {
                if (inited) {
                    return;
                }
                inited = true;
                Vial._startApplication_Classic();
                Vial._vialSetWindowSize(innerWidth * devicePixelRatio, innerHeight * devicePixelRatio);
                function renderLoop() {
                    Vial._vialRedraw();
                    setTimeout(renderLoop, 1000 / 10);
                }
                renderLoop();
                document.querySelector("#canvas").style.zIndex = 100;
            });
            document.querySelector("#draw").addEventListener("click", () => {
                Vial._vialRedraw();
            });
            const ev = {
                lmb: false,
                mmb: false,
                rmb: false,
                ctrlKey: false,
                shiftKey: false,
                altKey: false,
                x: 0,
                y: 0,
                dbl: false,
                wheel: 0,
            }

            function sendMouseEvent() {
                if (!inited) {
                    return;
                }
                console.log("sending mouse data.");
                Vial._processMouseEvent(ev.lmb, ev.mmb, ev.rmb, ev.ctrlKey, ev.shiftKey, ev.altKey, Math.floor(ev.x * devicePixelRatio), Math.floor(ev.y * devicePixelRatio), ev.dbl, ev.wheel);
                ev.wheel = 0;
                ev.dbl = false;
            }
            const queueMouseEvent = debounce(sendMouseEvent, 1000 / 60);
            const canvas = document.querySelector("#canvas");
            canvas.addEventListener("mousedown", (event) => {
                if (event instanceof MouseEvent) {
                    switch (event.button) {
                        case 0:
                            ev.lmb = true;
                            break;
                        case 1:
                            ev.mmb = true;
                            break;
                        case 2:
                            ev.rmb = true;
                            break;

                        default:
                            break;
                    }
                    ev.ctrlKey = event.ctrlKey;
                    ev.altKey = event.altKey;
                    ev.shiftKey = event.shiftKey;
                    ev.x = event.layerX;
                    ev.y = event.layerY;
                    queueMouseEvent();
                }
            });
            canvas.addEventListener("dblclick", () => {
                ev.dbl = true;
                queueMouseEvent();
            });
            canvas.addEventListener("wheel", (e) => {
                ev.wheel += Math.min(Math.max(-1, e.deltaY), 1);
                queueMouseEvent();
            });
            canvas.addEventListener("mouseup", (event) => {
                if (event instanceof MouseEvent) {
                    switch (event.button) {
                        case 0:
                            ev.lmb = false;
                            break;
                        case 1:
                            ev.mmb = false;
                            break;
                        case 2:
                            ev.rmb = false;
                            break;

                        default:
                            break;
                    }
                    ev.ctrlKey = event.ctrlKey;
                    ev.altKey = event.altKey;
                    ev.shiftKey = event.shiftKey;
                    ev.x = event.layerX;
                    ev.y = event.layerY;
                    queueMouseEvent();
                }
            });
            canvas.addEventListener("mousemove", (event) => {
                if (event instanceof MouseEvent) {
                    ev.ctrlKey = event.ctrlKey;
                    ev.altKey = event.altKey;
                    ev.shiftKey = event.shiftKey;
                    ev.x = event.layerX;
                    ev.y = event.layerY;
                    queueMouseEvent();
                }
            });
            const resizeHandler = () => {
                console.log("Triggering resize!");
                if (!inited) {
                    return;
                }
                Vial._vialSetWindowSize(innerWidth * devicePixelRatio, innerHeight * devicePixelRatio);
            };

            const debouncedHandler = debounce(resizeHandler, 850);
            addEventListener("resize", () => {
                debouncedHandler();
            });
        });
        function getProgramComponents(programID, kNumShaders) {
            kNumShaders ||= 21;
            return {
                "VertexShaderID": Math.floor(programID / kNumShaders),
                "FragmentShaderID": programID % kNumShaders
            };
        }
    </script>
</body>

</html>